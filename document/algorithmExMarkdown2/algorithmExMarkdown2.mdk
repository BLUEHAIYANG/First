package:ctex
Title         : 算法设计实验二：分治法
Author        : 软工1802 兰海洋 U201817003
Logo          : True

[TITLE]

# Madoko 

Madoko is a fast markdown processor for writing professional articles
with a focus on simplicity and plain text readability.

* Read the [reference manual].
* Explore the upper-right toolbox menu to discover how Markdown works. 
* `Alt-Q` reformats the current paragraph.

Enjoy!

# 被一个算法问题困住了怎么办？
&emsp;&emsp;被困住大概有这么几种情况

* （1）常规办法代价太大
> 二维平面上有一堆点，找出其中两两距离最小的一点。那好，我两个两个一组找，按组比对，记录最小值。
这个做法简单明了！但是，但凡你敢在项目中使用这个算法，很有可能会被队友按在地上摩擦------但凡平面
上超过了十个点，你就会发现运行速度慢到不行----时间复杂度是O（n！）
* （2）不知道如何实现
> 紧接着上一点，如果你不想被队友按在地上摩擦，那你肯定要想办法把算法优化优化。但如果你跟我一样菜，
大抵也会碰到这样的情况：除了暴力解，我就不会了！

&emsp;&emsp;**在这种时候分治法应当是你第一个考虑的算法设计思想！！！！**

# 分治法是个啥
* 分治法是种算法设计思想，而且是超级常见的那种----《算法导论》介绍的第一种算法思想，
是基础中的基础。
* 第一步是通过把复杂的大问题分解成简单的小问题，这个好理解啊
* 第二步是挨个解决小问题，通常来说小问题更容易解决。这个也好办呐。但是难在最后一步：
* 第三步：解决完了小问题，就要将小问题的解结合起来变成大问题的解！这是分治法的难度和精髓所在！

# 为啥使用分治法
&emsp;&emsp;总结起来有两点：提供解决问题的思路；优化算法！---正好对应1中被困住的情况！

# 怎么使用分治法来解决问题？
## 首先以最近点对问题为例进行分析
&emsp;&emsp;分治法的三步走可以称为：分，治，合。

* 对于第一步：分，分解大问题。这一步只和问题规模n有关，思路很简单：降低规模即可！
> 平面上有n个点，我难以找出最近距离。那好，我降低问题规模，如果我以所有点的x坐标中位数为界限，将所有的点分成
两个部分---左边和右边。各自求解其最近点对。只有n/2个点，是不是就好做了一点？

&emsp;&emsp;当然，也许你注意到了这种分解出来的两个子问题的解并不足以解决父问题，
分解的过程有缺憾！不要怕！之后讨论的第三步的合并步骤将会讨论并解决解决这个问缺憾。
在“分”这一步时不要惧怕，大胆去想，因为“合”的步骤就是为了弥补“分”的缺憾。


* 第二步：治，解决小问题。解决分解后的简单小问题
> 如果降低问题规模到最后，只有三个点，甚至两个点，我是不是直接就能做出来？

* 第三步，万众瞩目的：合，合并小问题的解，得到大问题的解。这一步没有定法，但和前两步息息相关。
也是分治法最核心的最关键的步骤。
> 你应当留意到，处在界限两侧，离界限最近的一些点，在跨越了界限之后，有可能出现最近距离，而这正是
第一步分解问题时没有涵盖到的，现在就要着力解决这个问题。如果仅仅是体会分治法的思维，不必拘泥于具体的算法实现，但是要牢记本步骤
的作用是弥补分解的缺憾，整合小问题的答案。
>


![QQ截图20200424201210]

[QQ截图20200424201210]: images/QQ-20200424201210.png "QQ截图20200424201210" { width:auto; max-width:90% }

&emsp;&emsp;在之前的计算中，我们可以得到左右两侧n/2个点之间的最小距离，δmin就是它们当中的最小值
以L为中心， 为半径划分一个长带，最小点对还有可能存在于SL和SR的交界处，
p点和q点分别位于SL和SR的虚线范围内，只有在这个范围内，p点和q点之间的距离才会小于δ，
最小点对计算才有意义。在这个范围内，从左侧选取一个点，分别与右侧所有的点一一暴力比对，代价已经可以接受。

&emsp;&emsp;至此，我们得到了：左半部的最近距离，右半部的最近距离，以及跨越左右部分的最近距离。
解就是它们当中的最小值；

## 以矩阵乘法为例解释优化算法的思路
&emsp;&emsp;上一部分已经详细描述了如何按照分治法的思路来思考解决方案。现在介绍通过主方法来优化算法的思路

&emsp;&emsp;我们知道n*n的矩阵乘法，按照定义，时间复杂度是O（n^3）。现在思考有没有可能降低这个复杂度。稍后

* 分治法之所以可以用来优化算法，我觉得主方法是最大的倚仗。不妨按照上面提及的分治合步骤考虑如何使用分治法
来设计一个新算法。我想此时应该很容易做到
* 请思考片刻。


* 常规的分治算法会将两个n*n的矩阵分解成八个n/2\*n/2的矩阵，分别相乘，主方法递归式为：
T(n) = 8T(n/2) + O(n^2),容易分析得知，这样分解的方式并没有降低时间复杂度。但是，如果你只凭自己思考
出这个做法，已经表明你摸到了分治算法设计思想的边。

* 主方法的意义在于为优化算法提供了重要思路：**减少分解问题时子问题的个数，增加问题被降低的规模**。
以上分治算法有多达8个n/2规模的子问题，如果能够减少哪怕1个，就可以达到优化的目的。我想，这应该就是
strassen设计strassen算法的出发点。
* strassen算法是通过一系列巧妙无比的配凑方式，使得最后只需要进行7次n/2\*n/2小矩阵乘法。
这就达成了优化的目的。
* 对于strassen算法，需要注意的是它优化算法的思路---减少了1个分解出来的子问题。而不要陷在具体的
配凑细节上。

# 有关实验报告的补充
&emsp;&emsp;如果是作为我自己的学习博客，以上内容已经足够了。但是要作为上交的实验报告，还
缺少一些东西，在这里补充
## strassen矩阵乘法
### 实验结果

* 解释说明：矩阵1和矩阵2均为随机生成，经过多次随机测试，常规矩阵乘法和strassen生成的二维数组
的值都是相同的。限于篇幅，只在这里粘贴其中一次测试结果。

![QQ截图20200425084754]

[QQ截图20200425084754]: images/QQ-20200425084754.png "QQ截图20200425084754" { width:auto; max-width:90% }

### strassen算法和常规矩阵乘法的效率对比
使用主方法分析可知，strassen算法的时间复杂度是O（n^2.81）,优于常规矩阵乘法

## 最近点对距离
* 解释说明：所有点均为随机生成。由结果可知实现正确。

![QQ截图20200425093145]

[QQ截图20200425093145]: images/QQ-20200425093145.png "QQ截图20200425093145" { width:auto; max-width:90% }


##思考题
### 分治法的三个步骤是什么？如何证明分治算法的正确性？
* 分治法的三个步骤已在之前详细描述：分，治，合
* 可以使用循环不变时证明分治算法的正确性。循环不变式和数学归纳法有异曲同工之妙。证明算法的初状态
正确，在迭代的过程当中每一步也都是正确的，这样结果必然是正确的的。（感觉分治法循环不变式与下一个实验
的动态规划状态转移方程是一对counterpart）

### 用主方法求解strassen矩阵乘法和最近点对距离的递归分析结果
* strassen矩阵乘法：T(n) = 7 T(n/2) + O(n^2),故时间复杂度是O(n^2.81) 附加开支来自于矩阵加减法
* 最近点对距离：T(n) = 2T(n/2) + O(n)。故时间复杂度是O(nlogn)。附加开支来自于合并过程：
遍历所有点，找到距离中轴在δmin范围内的点。

### 如何修改strassen方法，使得其可以作用于大小不必为2的幂的矩阵？
* 根据矩阵乘法的性质，可以进行预处理，对矩阵补零成2的幂的矩阵。


[reference manual]: http://research.microsoft.com/en-us/um/people/daan/madoko/doc/reference.html  "Madoko reference manual"
