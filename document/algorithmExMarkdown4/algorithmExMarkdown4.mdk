package:ctex
Title         : 贪婪算法
Author        : 软工1802  兰海洋  U201817003
Logo          : True

[TITLE]

# 写在前面
&emsp;&emsp;维基百科词条将分治法，动态规划，贪婪算法放在同一个分类之下。在学习的过程中我能够明显地
感受到贪婪算法与前二者之间存在紧密的联系，尤其是动态规划。

* 动态规划在构建最优解的过程中不断回溯
* 而贪婪算法永不回头

&emsp;&emsp;贪婪算法可以说是“最简单”的算法思想，因为选择当前情况下的最优解总是不太困难的，
构建一个局部最优解的耗费也必然少于全局最优解。但是贪婪也会带来“短视”的弊端，局部最优未必是全局最优，
就仿佛是，我们在人生的每个阶段都做自以为是最好的选择，最后也未必能得到人生的最优解。

* 除非我们能够证明当前做出的选择就是这辈子在这个年龄段的最好选择。那么我们会毫无迷茫（不用回溯）地走下去
* 一旦证明了正确性，贪婪算法往往就是最高效的一类算法，因为一条路走到黑，心无旁骛。
那么，要怎样证明贪婪算法的正确性呢？

# “剪切法”
&emsp;&emsp;简单粗暴的做法。可用来方便地证明贪婪算法的正确性。先看以下例子

## 求A到C的最近距离


![QQ截图20200428180203]

[QQ截图20200428180203]: images/QQ-20200428180203.png "QQ截图20200428180203" { width:auto; max-width:90% }

&emsp;&emsp;如果碰到这类算法问题，你可能会觉得很弱智-----不过这正是我选取这个例子的原因，为的是不让
繁杂的算法细节掩盖了你对“剪切法”本身的体会。

* 对于这个问题，我们理所应当地认为， A--B和B--C两个过程要选择直线路径，距离最短，那么如何证明
这个想法的正确性呢？
* （哪怕目前看起来是那么的直接，也请耐心地思考一下）
* 假设存在某一个全局最优解，在某个子过程Q当中，选择的过程的路径为q，q不是直线路径
* **那么我们可以尝试构建这样一个新的解：子过程Q当中的q路径“剪去”，再“粘贴”上直线路径。这样我们构建出来
了一个新的解，这个解显然比原本“假设的全局最优解”，更“优”**。
* 这样，在本例中，贪婪算法的正确性就得到了证明。

* 不过要提一下本例的缺陷之处：
  * 这个问题没有“重叠子问题”的性质，这也是本例的缺陷所在。希望读者暂时忽略这个细节。还是那句话
  重在体会剪切法思想。
  * 下面是另一个严谨的贪心算法的应用案例。
  
  



## 活动安排问题
问题描述：给定9个活动，以及它们的开始时间和结束时间，求9个活动中，在0--12点之间可以完成的最多的任务
数（即最多“兼容”的任务数目）

任务编号|开始时间|结束时间
--|--|--|
第1个|1：00|4：00|
第2个|3：00|5：00|
第3个|0：00|6：00|
第4个|5：00|7：00|
第5个|3：00|9：00|
第6个|5：00|9：00|
第7个|6：00|10：00|
第8个|8：00|11：00|
第9个|8：00|12：00|
第n个|i|j|

让我们开始按照惯例分析（惯例：先判断问题是否具有最优子结构和重叠子问题，若具有，那么可以考虑动态规划或者贪婪算法）

* 本问题是否具有最优子结构？
  * 本问题如何分解？可以分解成(0：00，k：00)，(k：00，12：00)
  * 显然，父问题的最优解必然包括子问题的最优解。所以本问题具有最优子结构
* 本问题是否具有重叠子问题？
  * 显然，也具有重叠子问题
  * 如果读者觉得不够显然，可以这样取特值直观地考虑一下：父问题（0：00，12：00）包含以下可能的子问题
  （0：00，11：00）  （0：00，10：00）  （0：00，9：00）...  （0：00，2：00），（0：00，1：00）
  显然这些子问题。对这些子问题再进行分解，都需要使用到（0：00，1：00）这个子问题的解。
  
  到目前为止，这两个性质的存在足够断定动态规划解决本问题了。在进一步就需要问这个问题了：

* 该问题是否具有贪心选择属性？
  * 先确定你**最关注的指标**，即：你打算贪什么。（我认为这一步是最重要的）
   * 每一次选择，都选择耗时最短的任务？
   * 每一次选择，都选择最早结束的任务？（应当选择贪这个，这应该足够直观）
  * 再根据你的指标，找出每一步选择过程中的局部最优解（即“最贪心的选择”）：每一次都在指定
  的时间段内选择结束时间最早的任务
  * 然后用上文提到的“剪切法”验证正确性。
   * 假设某个全局最优解在某一次选择时并没有选择最早结束的任务，成为Q任务。
   * **那么我们可以尝试构建这样一个解：将Q任务“剪下”，用该次选择中最早结束的任务替代Q任务，此时我们会发现
   构造的新解同样是全局最优的**

## 剪切法同样可以用来简洁快速地证明问题具有最优子结构。
&emsp;&emsp;接下来看一看贪心算法在图论问题中的应用

# 图论算法相关
## 最短路径问题
&emsp;&emsp;依照惯例，从简单的问题开始考虑：

* 给定一个有向权图，求指点节点S---A的最短路径。为了简单起见，权值不分


* （该问题显然具有最优子结构（由剪切法立得哟！），和重叠子问题（那可重叠的太多了））

请思考，是否可以使用贪心算法解决这个问题？

### 最直接的贪心法
&emsp;&emsp;以我的智商，当我第一次看到单源最短路径问题时，我想到的
方法是这样：

* 初状态：从源点s出发，选择离自己最近的点Q。
* 迭代状态：从Q点出发，选择离Q点最近的点
* 终止状态：到达目的地A点

&emsp;&emsp;显然这个算法肯定是不正确的：我根本无法保证一定能到达A点，即使存在一条抵达A的路线。
那么这是否说明贪心法无法使用在这里？

&emsp;&emsp;请看下一个算法

## Dijkstra算法

### 算法流程
&emsp;&emsp;这个算法改变了贪心的策略。为了简单起见，假设所有的权值互异（下一个部分讨论权值相同的情况）

* 将所有节点分为两个集合：T和V-A（其中V为全集），若某节点已经计算得到了最短路径距离，则加入T
* 开始：将源点S以权值0加入T
* 迭代：**在每一步迭代中，找到连接T和V-T的最短路径（在这一步体现出了贪心）**，
一旦确定了这个路径，就会有新的一个节点计算得到了最短路径距离，从而可以加入A。
* 结束：所有的节点都加入了T。返回S---A的最短距离

## BFS广度优先搜索

![QQ截图20200430093604]
[reference manual]: http://research.microsoft.com/en-us/um/people/daan/madoko/doc/reference.html  "Madoko reference manual"

![QQ截图20200430093735]

[QQ截图20200430093735]: images/QQ-20200430093735.png "QQ截图20200430093735" { width:auto; max-width:90% }

[QQ截图20200430093604]: images/QQ-20200430093604.png "QQ截图20200430093604" { width:auto; max-width:90% }
