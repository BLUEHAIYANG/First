package:ctex
Title         : 算法设计结业报告
Author        : 软工1802班 兰海洋 U201817003
Logo          : True

[TITLE]
# 分治法部分
## 被一个算法问题困住了怎么办？
&emsp;&emsp;被困住大概有这么几种情况

* （1）常规办法代价太大
> 二维平面上有一堆点，找出其中两两距离最小的一点。那好，我两个两个一组找，按组比对，记录最小值。
这个做法简单明了！但是，但凡你敢在项目中使用这个算法，很有可能会被队友按在地上摩擦------但凡平面
上超过了十个点，你就会发现运行速度慢到不行----时间复杂度是O（n！）
* （2）不知道如何实现
> 紧接着上一点，如果你不想被队友按在地上摩擦，那你肯定要想办法把算法优化优化。但如果你跟我一样菜，
大抵也会碰到这样的情况：除了暴力解，我就不会了！

&emsp;&emsp;**在这种时候分治法应当是你第一个考虑的算法设计思想！！！！**

## 分治法是个啥
* 分治法是种算法设计思想，而且是超级常见的那种----《算法导论》介绍的第一种算法思想，
是基础中的基础。
* 第一步是通过把复杂的大问题分解成简单的小问题，这个好理解啊
* 第二步是挨个解决小问题，通常来说小问题更容易解决。这个也好办呐。但是难在最后一步：
* 第三步：解决完了小问题，就要将小问题的解结合起来变成大问题的解！这是分治法的难度和精髓所在！

## 为啥使用分治法
&emsp;&emsp;总结起来有两点：提供解决问题的思路；优化算法！---正好对应1中被困住的情况！

## 怎么使用分治法来解决问题？
### 首先以最近点对问题为例进行分析
&emsp;&emsp;分治法的三步走可以称为：分，治，合。

* 对于第一步：分，分解大问题。这一步只和问题规模n有关，思路很简单：降低规模即可！
> 平面上有n个点，我难以找出最近距离。那好，我降低问题规模，如果我以所有点的x坐标中位数为界限，将所有的点分成
两个部分---左边和右边。各自求解其最近点对。只有n/2个点，是不是就好做了一点？

&emsp;&emsp;当然，也许你注意到了这种分解出来的两个子问题的解并不足以解决父问题，
分解的过程有缺憾！不要怕！之后讨论的第三步的合并步骤将会讨论并解决解决这个问缺憾。
在“分”这一步时不要惧怕，大胆去想，因为“合”的步骤就是为了弥补“分”的缺憾。


* 第二步：治，解决小问题。解决分解后的简单小问题
> 如果降低问题规模到最后，只有三个点，甚至两个点，我是不是直接就能做出来？

* 第三步，万众瞩目的：合，合并小问题的解，得到大问题的解。这一步没有定法，但和前两步息息相关。
也是分治法最核心的最关键的步骤。
> 你应当留意到，处在界限两侧，离界限最近的一些点，在跨越了界限之后，有可能出现最近距离，而这正是
第一步分解问题时没有涵盖到的，现在就要着力解决这个问题。如果仅仅是体会分治法的思维，不必拘泥于具体的算法实现，但是要牢记本步骤
的作用是弥补分解的缺憾，整合小问题的答案。
>
![最近点对]

[最近点对]: images/-.png "最近点对" { width:auto; max-width:90% }

&emsp;&emsp;在之前的计算中，我们可以得到左右两侧n/2个点之间的最小距离，δmin就是它们当中的最小值
以L为中心， 为半径划分一个长带，最小点对还有可能存在于SL和SR的交界处，
p点和q点分别位于SL和SR的虚线范围内，只有在这个范围内，p点和q点之间的距离才会小于δ，
最小点对计算才有意义。在这个范围内，从左侧选取一个点，分别与右侧所有的点一一暴力比对，代价已经可以接受。

&emsp;&emsp;至此，我们得到了：左半部的最近距离，右半部的最近距离，以及跨越左右部分的最近距离。
解就是它们当中的最小值；

### 以矩阵乘法为例解释优化算法的思路
&emsp;&emsp;上一部分已经详细描述了如何按照分治法的思路来思考解决方案。现在介绍通过主方法来优化算法的思路

&emsp;&emsp;我们知道n*n的矩阵乘法，按照定义，时间复杂度是O（n^3）。现在思考有没有可能降低这个复杂度。稍后

* 分治法之所以可以用来优化算法，我觉得主方法是最大的倚仗。不妨按照上面提及的分治合步骤考虑如何使用分治法
来设计一个新算法。我想此时应该很容易做到
* 请思考片刻。


* 常规的分治算法会将两个n*n的矩阵分解成八个n/2\*n/2的矩阵，分别相乘，主方法递归式为：
T(n) = 8T(n/2) + O(n^2),容易分析得知，这样分解的方式并没有降低时间复杂度。但是，如果你只凭自己思考
出这个做法，已经表明你摸到了分治算法设计思想的边。

* 主方法的意义在于为优化算法提供了重要思路：**减少分解问题时子问题的个数，增加问题被降低的规模**。
以上分治算法有多达8个n/2规模的子问题，如果能够减少哪怕1个，就可以达到优化的目的。我想，这应该就是
strassen设计strassen算法的出发点。
* strassen算法是通过一系列巧妙无比的配凑方式，使得最后只需要进行7次n/2\*n/2小矩阵乘法。
这就达成了优化的目的。
* 对于strassen算法，需要注意的是它优化算法的思路---减少了1个分解出来的子问题。而不要陷在具体的
配凑细节上。



# 动态规划

## 写在前面
&emsp;&emsp;在本课程相关的实验中，需要解决“最长公共子序列”问题，我在上学期学习《数据结构》这门课时已经了解
并实现过这个算法。但是重新看到这个问题时，我顿时感到悲哀：**我已经忘记怎么实现了**。但是我清楚地
记得如果要解决这个问题：需要一个“状态转移方程”，只要有了它我就可以很快地运用动态规划算法
来解决这个问题。

&emsp;&emsp;我忘记了这个状态转移方程。
虽然我只要动动手指就能在老师的PPT，或者随便网上搜索一下，找到我需要的这个状态转移方程。然后依据
它来实现算法即可，但是这样没有多大意义---------

&emsp;&emsp;因为我根本不知道为什么要使用动态规划，也不知道动态规划为什么是这个样子。如果一个算法
问题出现在“动态规划”的分类之下，那我掌握的只不过是，自动地开始按照动态规划的“模板”思考解决方案。这样
的状态真是太糟糕了

## 从分治法说起
&emsp;&emsp;在上一个实验中，我了解到分治法三个步骤：分，治，合，并且分治法可以为优化算法和实现算法
提供思路，“分而治之”是其核心概念---------把大问题分成小问题，逐个击破，这种方法的使用范围非常之广：
因为一旦输入规模降低，难度总是会下降；如果输入只有寥寥几个，问题立刻变得非常简单-----几乎所有的问题都
有这样的趋势。

&emsp;&emsp;所以我本能地想到，能用动态规划解决的问题难道不能用分治法解决么？我为什么不能用分治法
的思考步骤来思考那些出现在“动态规划”分类之下的算法问题？

&emsp;&emsp;当然，看到这里你可能会吐槽：**你都把动态规划学完了，怎么还会问出这个问题。**
动态规划仍然应用了“分而治之”的想法。动态规划和分治法的区别就是在于分治法的子问题是独立的
而动态规划的子问题是不独立的（存在重叠子问题）。

&emsp;&emsp;是啊，我确实得惭愧，如此看到，我在之前的学习当中不知不觉将分治法和动态规划完全当成了
风马牛不相及的两种算法设计思想，之前的学习简直是建立在空中楼阁上。接下来的实验内容，我会先以分治法
的思想为基础，体会动态规划的思想。


## 动态规划最简单的案例----斐波那契数列
* 斐波那契数列定义式：f(0) = 1; f(1) = 1; f(n) = f(n - 1) + f(n - 2);这个定义的结构实在太符合
分治法的思想了 
  * 分：输入规模n降低为了n - 1和n - 2
  * 治：规模降低到0 和 1，直接有解
  * 合：依据定义合并解即可。
  
  简直顺理成章，水到渠成。这就是妥妥的分治法思想！
  唯一的问题只在于递归调用树是指数阶的。有太多的相同的子问题被重复计算。
  
  


![20190418224254995]

[20190418224254995]: images/20190418224254995.png "20190418224254995" { width:auto; max-width:90% }


* 为了解决相同子问题被重复计算的问题，只要引入“记忆”功能即可。将已经计算出的子问题结果存储起来，
以后需要的话。只需要直接拿结果即可。这张图我非常喜欢，感觉说出了动态规划的精髓


![QQ截图20200507091047]

[QQ截图20200507091047]: images/QQ-20200507091047.png "QQ截图20200507091047" { width:auto; max-width:90% }


***我想这就是动态规划和分治法最大的（我甚至觉得可以说是“唯一的”）区别了。***

## 只不过是合并步骤有点新意------硬币找零问题

* 问题：如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？
  * 分：把11元分成两堆，有这些种分法：1和10元，2和9，...，5和6，或者0元和唯一的一张11元纸币（假如存在）
  * 治：规模降低到0时，直接有解f(0) = 0;
  * 合：
  
  > f(n) = min\[f(n - 1) + f(1),f(n - 2) + f(2),....,f(n/2) + f(n - n / 2)\]，若没有面值为n的纸币。
  
  > f(n) = 1,若有面值为n的纸币。
  
 这不就得了！在上次实验当中，我们提到，合并步骤的是分治法的关键和精髓，在这里也是如此。
 
 但是，动态规划的分解与常规分治法的分法还是有区别的：常规分治法往往分解成规模相等的几部分，
 而动态规划的分解方式显然更加灵活，在本例中，用5种方式将11元分成了两堆。在下一个例子当中，
 动态规划对于子问题的分解的灵活性体现的更加明显------------


## 分解步骤有新意------最长公共子序列，背包问题
&emsp;&emsp;这一部分与开头相呼应。我尝试避免毫无根据地使用动态规划，而打算从分治法的模式开始
尝试解决。在这个过程中，暴露了我在分解问题时非常机械：

&emsp;&emsp;**我好像只会尝试将输入规模n对半分**

* 我尝试将输入的两个字符串分为四个，例如

 * S1:ACCGGTCGAGATGCAG ---> s11:ACCGGTCG   s12:AGATGCAG
 * S2:GTCGTTCGGAATGCAT ---> s21:GTCGTTCG   s22:GAATGCAT

* 可是我要如何处理这四个字符串呢？分解步骤到此为止了。

## 状态转移方程 
* 相当于分治法的循环不变式，说实话，本算法如果直接让我想要如何分解，恐怕不是一下子能够想到的。
以最长公共子序列为例，它的状态转移方程是怎么想到的呢？------
  * 当前的状态，一定由之前的状态决定。自底向上，稳扎稳打，逐步推进。

这里有图

* 虽然动态规划有两种一般的范式：自顶向下递归，自底向上状态转移，但本质上都是自底向上的---由前一个
状态唯一地确定后一个状态，这一点同分治法类似，不同之处在于，动态规划算法往往面对分支---

### 如何分解？
* 对于动态规划问题，它的最简单的初状态是什么？----这一步要判断影响因素的种类

  * 在本例中，两个字符串自然是越短越好，最简单的状态无非就是两个字符串的长度均为1。那么我们可以将
  两个字符串各自的长短视为影响因素s1_length,s2_length

* 根据第一步，构建状态转移方程。
  * 在s1.length和s2.length均较小时，很容易可以为结果数组C赋初值
  * 考虑一般情况下，C[i,j]的取值：根据上一步确定的影响因素的种类，缓慢地改变不同影响因素的数值，
  在此过程中分情况讨论,用之前已得出的解构建当前所需要的的解！（分解的精髓在此！！）
  
  下面以背包问题详细论述这个过程



### 背包问题
* 问题描述：
有N件物品和一个容量为V的背包。第i件物品的重量是c\[i]，价值是w\[i]。
求解将哪些物品装入背包可使价值总和最大。

* 第一步：判断影响因素:
  * (1)N件物品
  * (2)背包容量V
  
  如果这两个变量值足够小，小到1或者0，是不是一下子就可以解决！

* 第二步：构建状态转移方程
 * （1）由第一步可知有两个影响因素，故创建一个二维数组tab[N,V]记录结果，赋基准值
 * （2）对于任意一种状态tab[i,j]，分析它与tab[i-n1,j-n2]之前存在的联系。
 tab\[i]\[j] = max(tab\[i-1]\[j-weight\[i]]+value\[i],tab\[i-1]\[j])



 ### 重新来看硬币找零问题
 &emsp;&emsp;在之前的内容中，我站在分治法的角度给出了一个转移方程，当时是简单地把一堆钱分成两堆
 > f(n) = min\[f(n - 1) + f(1),f(n - 2) + f(2),....,f(n/2) + f(n - n / 2)\]，若没有面值为n的纸币。
  
  > f(n) = 1,若有面值为n的纸币。

* 经过5.2，5.3节的讨论，不妨考虑一下能不能按照类似的步骤再给出一个转移方程呢？
* 请思考片刻，你已有能力自己得出答案

------------------------------------


* 第一步分析影响因素：面值种类money_kind_count，找零数额n
* 第二步构建转移方程
  * 因为有二个影响因素，故创建二维数组result\[money_kind_count]\[n]
  * 转移方程为：result\[i]\[j] = min(result\[i - 1]\[j],result\[i]\[j -k *  value\[i]]+ k)
  * 解释一下转移方程：
   * result\[i]\[j]：使用前i种面值的硬币，找零n元所需的最少硬币数
   * result\[i - 1]\[j]：未使用第i种硬币
   * result\[i]\[j -k *  value\[i]]+ k:使用了k张第i种硬币，找零n元所需的最小硬币数
   


## 小结
 * （1）动态规划思想脱胎于分治法思想
 * （2）动态规划的状态转移方程，和，常规分治法的循环不变式，有异曲同工之妙
 * （3）构建转移方程的关键在于：找到所有对解产生影响的因素！

# 贪婪算法
## 写在前面
&emsp;&emsp;维基百科词条将分治法，动态规划，贪婪算法放在同一个分类之下。在学习的过程中我能够明显地
感受到贪婪算法与前二者之间存在紧密的联系，尤其是动态规划。

* 动态规划在构建最优解的过程中不断回溯
* 而贪婪算法永不回头

&emsp;&emsp;贪婪算法可以说是“最简单”的算法思想，因为选择当前情况下的最优解总是不太困难的，
构建一个局部最优解的耗费也必然少于全局最优解。但是贪婪也会带来“短视”的弊端，局部最优未必是全局最优，
就仿佛是，我们在人生的每个阶段都做自以为是最好的选择，最后也未必能得到人生的最优解。

* 除非我们能够证明当前做出的选择就是这辈子在这个年龄段的最好选择。那么我们会毫无迷茫（不用回溯）地走下去
* 一旦证明了正确性，贪婪算法往往就是最高效的一类算法，因为一条路走到黑，心无旁骛。
那么，要怎样证明贪婪算法的正确性呢？

## “剪切法”
&emsp;&emsp;简单粗暴的做法。可用来方便地证明贪婪算法的正确性。先看以下例子

### 求A到C的最近距离

![贪婪算法 AC距离]

[贪婪算法 AC距离]: images/-AC-.png "贪婪算法 AC距离" { width:auto; max-width:90% }

&emsp;&emsp;如果碰到这类算法问题，你可能会觉得很弱智-----不过这正是我选取这个例子的原因，为的是不让
繁杂的算法细节掩盖了你对“剪切法”本身的体会。

* 对于这个问题，我们理所应当地认为， A--B和B--C两个过程要选择直线路径，距离最短，那么如何证明
这个想法的正确性呢？
* （哪怕目前看起来是那么的直接，也请耐心地思考一下）
* 假设存在某一个全局最优解，在某个子过程Q当中，选择的过程的路径为q，q不是直线路径
* **那么我们可以尝试构建这样一个新的解：子过程Q当中的q路径“剪去”，再“粘贴”上直线路径。这样我们构建出来
了一个新的解，这个解显然比原本“假设的全局最优解”，更“优”**。
* 这样，在本例中，贪婪算法的正确性就得到了证明。

* 不过要提一下本例的缺陷之处：
  * 这个问题没有“重叠子问题”的性质，这也是本例的缺陷所在。希望读者暂时忽略这个细节。还是那句话
  重在体会剪切法思想。
  * 下面是另一个严谨的贪心算法的应用案例。
  
  



### 活动安排问题
问题描述：给定9个活动，以及它们的开始时间和结束时间，求9个活动中，在0--12点之间可以完成的最多的任务
数（即最多“兼容”的任务数目）

任务编号|开始时间|结束时间
--|--|--|
第1个|1：00|4：00|
第2个|3：00|5：00|
第3个|0：00|6：00|
第4个|5：00|7：00|
第5个|3：00|9：00|
第6个|5：00|9：00|
第7个|6：00|10：00|
第8个|8：00|11：00|
第9个|8：00|12：00|
第n个|i|j|

让我们开始按照惯例分析（惯例：先判断问题是否具有最优子结构和重叠子问题，若具有，那么可以考虑动态规划或者贪婪算法）

* 本问题是否具有最优子结构？
  * 本问题如何分解？可以分解成(0：00，k：00)，(k：00，12：00)
  * 显然，父问题的最优解必然包括子问题的最优解。所以本问题具有最优子结构
* 本问题是否具有重叠子问题？
  * 显然，也具有重叠子问题
  * 如果读者觉得不够显然，可以这样取特值直观地考虑一下：父问题（0：00，12：00）包含以下可能的子问题
  （0：00，11：00）  （0：00，10：00）  （0：00，9：00）...  （0：00，2：00），（0：00，1：00）
  显然这些子问题。对这些子问题再进行分解，都需要使用到（0：00，1：00）这个子问题的解。
  
  到目前为止，这两个性质的存在足够断定动态规划解决本问题了。在进一步就需要问这个问题了：

* 该问题是否具有贪心选择属性？
  * 先确定你**最关注的指标**，即：你打算贪什么。（我认为这一步是最重要的）
   * 每一次选择，都选择耗时最短的任务？
   * 每一次选择，都选择最早结束的任务？（应当选择贪这个，这应该足够直观）
  * 再根据你的指标，找出每一步选择过程中的局部最优解（即“最贪心的选择”）：每一次都在指定
  的时间段内选择结束时间最早的任务
  * 然后用上文提到的“剪切法”验证正确性。
   * 假设某个全局最优解在某一次选择时并没有选择最早结束的任务，成为Q任务。
   * **那么我们可以尝试构建这样一个解：将Q任务“剪下”，用该次选择中最早结束的任务替代Q任务，此时我们会发现
   构造的新解同样是全局最优的**

### 剪切法同样可以用来简洁快速地证明问题具有最优子结构。
&emsp;&emsp;接下来看一看贪心算法在图论问题中的应用

## 图论算法相关
### 最短路径问题
&emsp;&emsp;依照惯例，从简单的问题开始考虑：

* 给定一个有向权图，求指点节点S---A的最短路径。为了简单起见，权值不分


* （该问题显然具有最优子结构（由剪切法立得哟！），和重叠子问题（那可重叠的太多了））

请思考，是否可以使用贪心算法解决这个问题？

#### 最直接的贪心法
&emsp;&emsp;以我的智商，当我第一次看到单源最短路径问题时，我想到的
方法是这样：

* 初状态：从源点s出发，选择离自己最近的点Q。
* 迭代状态：从Q点出发，选择离Q点最近的点
* 终止状态：到达目的地A点

&emsp;&emsp;显然这个算法肯定是不正确的：我根本无法保证一定能到达A点，即使存在一条抵达A的路线。
那么这是否说明贪心法无法使用在这里？

&emsp;&emsp;请看下一个算法

#### Dijkstra算法

##### 算法流程
&emsp;&emsp;这个算法改变了贪心的策略。为了简单起见，假设所有的权值互异（下一个部分讨论权值相同的情况）

* 将所有节点分为两个集合：T和V-A（其中V为全集），若某节点已经计算得到了最短路径距离，则加入T
* 开始：将源点S以权值0加入T
* 迭代：**在每一步迭代中，找到连接T和V-T的最短路径（在这一步体现出了贪心）**，
一旦确定了这个路径，就会有新的一个节点计算得到了最短路径距离，从而可以加入A。
* 结束：所有的节点都加入了T。返回S---A的最短距离

#### BFS广度优先搜索


## 小结
* 一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。
由于贪心法的高效性以及其所求得的答案比较接近最优结果，
贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。
* 选择合适的贪婪的“指标”，有助于构造一个贪婪算法。
* 剪切法是证明贪婪算法正确性的一个简单高效的方法

[reference manual]: http://research.microsoft.com/en-us/um/people/daan/madoko/doc/reference.html  "Madoko reference manual"
