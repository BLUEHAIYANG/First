package:ctex
Title         : 贪婪算法
Author        : 软工1802  兰海洋  U201817003
Logo          : True

[TITLE]

# 写在前面
&emsp;&emsp;维基百科词条将分治法，动态规划，贪婪算法放在同一个分类之下。在学习的过程中我能够明显地
感受到贪婪算法与前二者之间存在紧密的联系，尤其是动态规划。

* 动态规划在构建最优解的过程中不断回溯
* 而贪婪算法永不回头

&emsp;&emsp;贪婪算法可以说是“最简单”的算法思想，因为选择当前情况下的最优解总是不太困难的，
构建一个局部最优解的耗费也必然少于全局最优解。但是贪婪也会带来“短视”的弊端，局部最优未必是全局最优，
就仿佛是，我们在人生的每个阶段都做自以为是最好的选择，最后也未必能得到人生的最优解。

* 除非我们能够证明当前做出的选择就是这辈子在这个年龄段的最好选择。那么我们会毫无迷茫（不用回溯）地走下去
* 一旦证明了正确性，贪婪算法往往就是最高效的一类算法，因为一条路走到黑，心无旁骛。
那么，要怎样证明贪婪算法的正确性呢？

# “剪切法”
&emsp;&emsp;简单粗暴的做法。应用起来十分方便。先看以下例子

## 求A到C的最近距离


![QQ截图20200428180203]

[QQ截图20200428180203]: images/QQ-20200428180203.png "QQ截图20200428180203" { width:auto; max-width:90% }

&emsp;&emsp;如果碰到这类算法问题，你肯定会觉得很弱智-----不过这正是我选取这个例子的原因，为的是不让
繁杂的算法细节掩盖了你对“剪切法”本身的体会。

* 对于这个问题，我们理所应当地认为， A--B和B--C两个过程要选择直线路径，距离最短，那么如何证明
这个想法的正确性呢？
* （哪怕目前看起来是那么的直接，也请耐心地思考一下）
* 假设存在某一个全局最优解，在某个子过程Q当中，选择的过程的路径为q，q不是直线路径
* **那么我们可以尝试构建这样一个新的解：子过程Q当中的q路径“剪去”，再“粘贴”上直线路径。这样我们构建出来
了一个新的解，这个解显然比原本“假设的全局最优解”，更“优”**。
* 这样，在本例中，贪婪算法的正确性就得到了证明。

* 不过要提一下本例的缺陷之处：
  * 这个问题没有“重叠子问题”的性质，这也是本例的缺陷所在。希望读者暂时忽略这个细节。还是那句话
  重在体会剪切法思想。
  * 下面是另一个严谨的贪心算法的应用案例。
  
  



## 活动安排问题
问题描述：给定9个活动，以及它们的开始时间和结束时间，求9个活动中，在0--12点之间可以完成的最多的任务
数（即最多“兼容”的任务数目）

任务编号|开始时间|结束时间
--|--|--|
第1个|1：00|4：00|
第2个|3：00|5：00|
第3个|0：00|6：00|
第4个|5：00|7：00|
第5个|3：00|9：00|
第6个|5：00|9：00|
第7个|6：00|10：00|
第8个|8：00|11：00|
第9个|8：00|12：00|
第n个|i|j|

让我们开始按照惯例分析（惯例：先判断问题是否具有最优子结构和重叠子问题，若具有，那么可以考虑动态规划或者贪婪算法）

* 本问题是否具有最优子结构？
  * 本问题如何分解？可以分解成(0：00，k：00)，(k：00，12：00)
  * 显然，父问题的最优解必然包括子问题的最优解。所以本问题具有最优子结构
* 本问题是否具有重叠子问题？
  * 显然，也具有重叠子问题
  * 如果读者觉得不够显然，可以这样取特值直观地考虑一下：父问题（0：00，12：00）包含以下可能的子问题
  （0：00，11：00）  （0：00，10：00）  （0：00，9：00）...  （0：00，2：00），（0：00，1：00）
  显然这些子问题。对这些子问题再进行分解，都需要使用到（0：00，1：00）这个子问题的解。
  
  到目前为止，这两个性质的存在足够断定动态规划解决本问题了。在进一步就需要问这个问题了：

* 该问题是否具有贪心选择属性？
  * 不要被这个属性的名字唬住了
  * 先找出每一步选择过程中的局部最优解（即“最贪心的选择”），然后用上文提到的“剪切法”验证正确性。

[reference manual]: http://research.microsoft.com/en-us/um/people/daan/madoko/doc/reference.html  "Madoko reference manual"
